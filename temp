class DecisionTree {

  public:

    // tree + data set specifications
    int maxTreeDepth;                   // max tree depth
    const static int n_features = 129;  // number of features
    const static int n_train = 1207;    // data for training
    const static int n_test = 213;      // data for testing

    // placeholder vectors because I can't figure out how to parse data nicely
    vector<vector<double>> trainingSet {n_train, vector<double> (n_features) };
    vector<vector<double>> testingSet {n_test, vector<double> (n_features) };

    // this is also hardcoded, ideally, we'd like to change this somehow
    double dataTrain[n_train][129]{     // training dataset
      #include "seals_train_c.csv"
    };
    double dataTest[213][129]{          // testing dataset
      #include "seals_test_c.csv"
    };

    // Constructor to initialize values
    DecisionTree(int depth) {
      maxTreeDepth = depth;

      //  copy contents of the arrays over to better vector format
      for (int i=0; i < n_features; i++) {
        for (int j=0; j < n_train; j++) {trainingSet[j][i] = dataTrain[j][i];}
        for (int j=0; j < n_test; j++) {testingSet[j][i] = dataTest[j][i];}
      }

      cout << "Finish initialization of dataset..." << endl;
    }

    // start building the tree iteratively
    Node train() {
      Node rootNode = DecisionTree::buildTree(trainingSet);
      return rootNode;
    }

  private:

    int currentDepth = 0;               // current depth of tree

    // iteratively return nodes based on largest info gain
    Node buildTree(vector<vector<double>>& dataset) {

      while (currentDepth < maxTreeDepth){

        vector<double> bestSplit = calculateBestSplit(dataset);

        cout << bestSplit[0] << " " << bestSplit[1] << " " << bestSplit[2] << endl;
        currentDepth++;
      }

      // change this!
      Node test(0,50,0,0,false);
      return test;
    }

    vector<double> calculateBestSplit(vector<vector<double>>& dataset) {

      double bestInfoGain = -numeric_limits<double>::max();
      double bestCutFeature = 0, bestCutThreshold = 0;

      // iterate over all features (feature 0 == label!)
      for (int feature=1; feature < n_features; feature++) {
        
        // prepare possible threshold values
        vector<double> cuts(dataset.size());
        for (int i=0; i < dataset.size(); i++) {cuts[i] = dataset[i][feature];};
        
        // loop over all possible splits
        for (double value : cuts) {
          vector<vector<vector<double>>> split = splitDataset(dataset,feature,value);     // this is taking so much time
          vector<vector<double>> datasetLeft = split[1], datasetRight = split[2];
          int lengthLeft = datasetLeft.size(), lengthRight = datasetRight.size();

          // ensure resulting split doesn't yield empty set
          if (lengthLeft==0 || lengthRight==0){continue;}

          // calculate information gain
          double weightLeft = lengthLeft / (lengthLeft + lengthRight);
          double weightRight = lengthRight / (lengthLeft + lengthRight);
          double giniParent = 0, giniLeft = 0, giniRight = 0;

          for (int cls : {0,1}) {
            int scoreParent = 0, scoreLeft = 0, scoreRight = 0;

            for (vector<double> datapoint : dataset) {if (datapoint[0]==cls){ scoreParent +=1; }}
            for (vector<double> datapoint : datasetLeft) {if (datapoint[0]==cls){ scoreLeft +=1; }}
            for (vector<double> datapoint : datasetRight){if (datapoint[0]==cls){ scoreRight +=1;}}

            giniParent += pow(scoreParent/dataset.size(),2);
            giniLeft += pow(scoreLeft/lengthLeft,2);
            giniRight += pow(scoreRight/lengthRight,2);
          }

          double currentInfoGain = giniParent - ( weightLeft*(1-giniLeft) + weightRight*(1-giniRight) );

          if (currentInfoGain > bestInfoGain) {
            bestInfoGain = currentInfoGain;
            bestCutFeature = feature;
            bestCutThreshold = value;
          }
        }
      }

      vector<double> bestSplit = {bestCutFeature,bestCutThreshold,bestInfoGain};

      return bestSplit;
    }

    vector<vector<vector<double>>> splitDataset(vector<vector<double>>& dataset, int feature, double threshold) {

      vector<vector<double>> datasetLeft, datasetRight;
      vector<vector<double>> labels {2,vector<double>()};
      
      for (vector<double> datapoint : dataset) {
        if(datapoint[feature] < threshold) {
          datasetLeft.push_back(datapoint);
          labels[0].push_back(datapoint[0]);
        } 
        else {
          datasetRight.push_back(datapoint);
          labels[1].push_back(datapoint[0]);
        }
      }

      vector<vector<vector<double>>> split = {labels, datasetLeft, datasetRight};

      return split;
    }
};